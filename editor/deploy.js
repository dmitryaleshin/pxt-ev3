"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.deployCoreAsync=exports.enableWebSerialAsync=exports.canUseWebSerial=exports.initAsync=exports.debug=exports.ev3=void 0;var ParityType,HF2=pxt.HF2,UF2=pxtc.UF2;const wrap_1=require("./wrap"),dialogs_1=require("./dialogs");function debug(){return initHidAsync().then(e=>e.downloadFileAsync("/tmp/dmesg.txt",e=>console.log(pxt.Util.uint8ArrayToString(e))))}exports.debug=debug,function(e){e[e.none=0]="none",e[e.even=1]="even",e[e.odd=2]="odd",e[e.mark=3]="mark",e[e.space=4]="space"}(ParityType=ParityType||{});class WebSerialPackageIO{constructor(e,t){this.port=e,this.options=t,console.log("serial: new io")}bufferSize(e){return HF2.read16(e,0)+2}async readSerialAsync(){this._reader=this.port.readable.getReader();let e;for(var t=this._reader;t===this._reader;){var r,n=(await this._reader.read())["value"];(e=e?((r=new Uint8Array(e.length+n.byteLength)).set(e,0),r.set(n,e.length),r):n)&&(console.debug("Current buffer size: "+e.length),r=this.bufferSize(e),e.length==r?(this.onData(new Uint8Array(e)),e=void 0):e.length>r?(console.warn("Received larger bufer then command command: "+e.length+" recieved but waiting for "+r),n=e.slice(0,r-1),this.onData(new Uint8Array(n)),n=e.slice(r,e.length-1),e=n,console.debug("Next buffer size: "+this.bufferSize(e))):console.warn("Incomplete command: "+e.length+" recieved but waiting for "+r+". Keep waiting..."))}}static isSupported(){return!!navigator.serial}static async mkPacketIOAsync(){var t=navigator.serial;if(t)try{var r,n={};const s=await t.requestPort(n);let e=WebSerialPackageIO.portIos.filter(e=>e.port==s)[0];return e||(r={baudRate:460800,buffersize:4096},e=new WebSerialPackageIO(s,r),WebSerialPackageIO.portIos.push(e)),e}catch(e){console.log("connection error",e)}throw new Error("could not open serial port")}error(e){throw console.error(e),new Error(lf("error on brick ({0})",e))}openAsync(){return console.log("serial: opening port"),this._reader?Promise.resolve():(this._reader=void 0,this._writer=void 0,this.port.open(this.options).then(()=>(this.readSerialAsync(),Promise.resolve())))}async closeAsync(){return pxt.U.delay(500)}reconnectAsync(){return this.openAsync()}disconnectAsync(){return this.closeAsync()}sendPacketAsync(e){return this._writer||(this._writer=this.port.writable.getWriter()),this._writer.write(e)}onDeviceConnectionChanged(e){throw new Error("onDeviceConnectionChanged not implemented")}onConnectionChanged(){throw new Error("onConnectionChanged not implemented")}isConnecting(){throw new Error("isConnecting not implemented")}isConnected(){throw new Error("isConnected not implemented")}disposeAsync(){return Promise.reject("disposeAsync not implemented")}}function hf2Async(){return(useWebSerial?WebSerialPackageIO:pxt.packetio).mkPacketIOAsync().then(e=>{let t=new wrap_1.Ev3Wrapper(e);return(exports.ev3=t).reconnectAsync(!0).then(()=>t)})}let useHID=!(WebSerialPackageIO.portIos=[]),useWebSerial=!1;function initAsync(){var e;return pxt.U.isNodeJS?useHID=!1:(e=/nodehid/i.test(window.location.href),pxt.BrowserUtils.isLocalHost()&&pxt.Cloud.localToken&&e&&(useHID=!0)),WebSerialPackageIO.isSupported()&&pxt.tickEvent("webserial.supported"),Promise.resolve()}function canUseWebSerial(){return WebSerialPackageIO.isSupported()}function enableWebSerialAsync(){return initPromise=void 0,useWebSerial=WebSerialPackageIO.isSupported(),(useHID=useWebSerial)?initHidAsync().then(()=>{}):Promise.resolve()}async function cleanupAsync(){if(exports.ev3){console.log("cleanup previous port");try{await exports.ev3.disconnectAsync()}catch(e){}finally{exports.ev3=void 0}}}exports.initAsync=initAsync,exports.canUseWebSerial=canUseWebSerial,exports.enableWebSerialAsync=enableWebSerialAsync;let initPromise;function initHidAsync(){return initPromise=initPromise||(useHID?cleanupAsync().then(()=>hf2Async()).catch(e=>(console.error(e),initPromise=null,useHID=!1,useWebSerial=!1,Promise.reject(e))):(useHID=!1,useWebSerial=!1,Promise.reject(new Error("no HID"))))}const fspath="../prjs/BrkProg_SAVE/",rbfTemplate=`
4c45474f580000006d000100000000001c000000000000000e000000821b038405018130813e8053
74617274696e672e2e2e0084006080XX00448581644886488405018130813e80427965210084000a
`;function deployCoreAsync(e){let n=e.downloadFileBaseName||"pxt",t=(n=n.replace(/^lego-/,""),fspath+n+".elf"),r=fspath+n+".rbf";var s=rbfTemplate.replace(/\s+/g,"").replace("XX",pxt.U.toHex(pxt.U.stringToUint8Array(t)));let o=pxt.U.fromHex(s),i=(pxt.HF2.write16(o,4,o.length),UF2.parseFile(pxt.U.stringToUint8Array(ts.pxtc.decodeBase64(e.outfiles[pxt.outputName()]))));var a,s=(e,t=null)=>{var r=UF2.newBlockFile();return r.filename="Projects/"+n+e,t&&UF2.writeBytes(r,0,t),r},c=s(".elf");for(a of i)UF2.writeBytes(c,a.targetAddr,a.data);s=UF2.concatFiles([c,s(".rbf",o)]),s=UF2.serializeFile(s);e.outfiles[pxtc.BINARY_UF2]=btoa(s);if(!useHID)return pxt.commands&&pxt.commands.electronDeployAsync?pxt.commands.electronDeployAsync(e):pxt.commands&&pxt.commands.saveOnlyAsync?pxt.commands.saveOnlyAsync(e):Promise.resolve();pxt.tickEvent("webserial.flash");let l;return initHidAsync().then(e=>((l=e).isStreaming&&pxt.U.userError("please stop the program first"),l.reconnectAsync(!1).catch(e=>((0,dialogs_1.bluetoothTryAgainAsync)().then(()=>l.disconnectAsync()).then(()=>pxt.U.delay(1e3)).then(()=>l.reconnectAsync()),Promise.reject(e))))).then(()=>l.stopAsync()).then(()=>l.rmAsync(t)).then(()=>l.flashAsync(t,UF2.readBytes(i,0,256*i.length))).then(()=>l.flashAsync(r,o)).then(()=>l.runAsync(r)).then(()=>pxt.U.delay(500)).then(()=>(pxt.tickEvent("webserial.success"),l.disconnectAsync())).catch(e=>(pxt.tickEvent("webserial.fail"),useHID=!1,useWebSerial=!1,Promise.reject(e)))}exports.deployCoreAsync=deployCoreAsync;